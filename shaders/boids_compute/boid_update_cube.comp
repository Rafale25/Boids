#version 430

layout(local_size_x=512, local_size_y=1, local_size_z=1) in;

struct Boid {
	vec3 pos;
	float a; // useless as fuck
	vec3 dir;
	float b; // useless as fuck
};

layout(std430, binding=0) readonly buffer boids_in {
	Boid boids[];
} In_boids;

layout(std430, binding=1) writeonly buffer boids_out {
	Boid boids[];
} Out_boids;

uniform int boid_count;
uniform float speed;
uniform float map_size;
uniform float view_distance;
uniform float view_angle;

uniform float separation_force;
uniform float alignment_force;
uniform float cohesion_force;

#define PI 3.1415926535897932384626

float map(float value, float min1, float max1, float min2, float max2) {
	return min2 + (value - min1) * (max2 - min2) / (max1 - min1);
}

float distSquared(vec3 A, vec3 B) {
    const vec3 C = A - B;
    return dot(C, C);
}

void main() {
	const uint id = gl_GlobalInvocationID.z * gl_NumWorkGroups.y * gl_NumWorkGroups.x +
					gl_GlobalInvocationID.y * gl_NumWorkGroups.x +
					gl_GlobalInvocationID.x;

	if (id >= boid_count) {
		return;
	}

	vec3 ourPos = In_boids.boids[id].pos + (In_boids.boids[id].dir * speed);
	vec3 ourDir = In_boids.boids[id].dir;

	int nb_flockmates = 0;
	vec3 averageDirection =	vec3(0.0, 0.0, 0.0);
	vec3 averagePosition =	vec3(0.0, 0.0, 0.0);
	vec3 totalForce =		vec3(0.0, 0.0, 0.0); // test, delete this later

	for (int i = 0 ; i < boid_count ; ++i) {
		if (id == i) continue; // don't check if itself

		const vec3 theirPos = In_boids.boids[i].pos;
		const vec3 theirDir = In_boids.boids[i].dir;

		// tests
		const vec3 p = theirPos;
		const vec3 v = ourPos;
		const vec3 d = ourDir;
		const float r = dot((p - v)/length(p - v), d/length(d));

		const float sqrDist = distSquared(ourPos, theirPos);
		if (sqrDist < view_distance * view_distance) {
			if (length(acos(r)) <= view_angle) {
				nb_flockmates += 1;
				averageDirection += theirDir;
				averagePosition += theirPos;

				// separation
				totalForce += (ourPos - theirPos) / sqrDist;
			}
		}
	}

	// separation
	ourDir += totalForce * separation_force;

	if (nb_flockmates != 0) {
		// alignment
		averageDirection /= nb_flockmates;
		ourDir += averageDirection * alignment_force;

		// cohesion
		averagePosition /= nb_flockmates;
		ourDir += -(ourPos - averagePosition) * cohesion_force;
	}

	// border limit
	const vec3 np = ourPos + (ourDir * speed);
	const float mp2 = map_size * 0.5;
	if (np.x < -mp2 || np.x > mp2 || np.y < -mp2 || np.y > mp2 || np.z < -mp2 || np.z > mp2) {
		const vec3 to_center = normalize(vec3(0, 0, 0) - ourPos);
		ourDir += to_center * 0.1;
	}

	Out_boids.boids[id].pos = ourPos;
	Out_boids.boids[id].dir = normalize(ourDir);
}
