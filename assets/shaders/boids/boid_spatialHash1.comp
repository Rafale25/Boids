#version 430

layout(local_size_x=512, local_size_y=1, local_size_z=1) in;

struct Boid {
    vec3 pos;
    float a; // useless as fuck
    vec3 dir;
    float b; // useless as fuck
};

// struct Hash {
//     uint cell_id;
//     uint boid_id;
// };

struct CellInfo {
    uint start;
    uint size;
};

/*
layout(std430, binding=0) buffer buffer_boids {
    Boid b_boid[];
};

layout(std430, binding=1) buffer buffer_unsorted {
    Hash b_unsorted[];
};

layout(std430, binding=2) buffer buffer_sorted {
    Hash b_sorted[];
};

layout(std430, binding=3) buffer buffer_cell_start {
    uint b_cell_start[];
};
*/


/* temporary solution */
layout(std430, binding=0) readonly buffer buffer_boids {
    Boid b_boid[];
};

// cell id of each boid
layout(std430, binding=1) buffer buffer_cell_id {
    uint b_cell_id[]; // boid_id = cell_id
};

// sorted list of boid_id based on grid cell
layout(std430, binding=2) buffer buffer_cell_info {
    CellInfo b_cell_info[]; // start, size
};

// sorted list of boid_id based on grid cell
// layout(std430, binding=3) writeonly buffer buffer_sorted_boids_id {
//     uint b_sorted_id[]; // cell_id... = boid_id
// };
/* ---- */


uniform int boid_count;
uniform float map_size;

/*
example: SH_size = 8 -> 8*8*8 = 512
how many cell in an axis
SH_size is not the size of the cell
*/
uniform int SH_size;

/*
const ivec3 cell_index3 = ivec3((boid.pos+(map_size/2)) / (map_size/SH_size));
uint cell_index = int((cell_index3.z) * (SH_size * SH_size) +
                ((cell_index3.y) * SH_size) +
                (cell_index3.x));
*/

// seems to be working
ivec3 getCellPos(vec3 p) {
    /* add map_size/2 to position because map is centered on origin
        divide by SH_size to convert xyz to cell indices on each axis */
    float cellSize = map_size / float(SH_size);
    return ivec3((p + (map_size/2.0)) / cellSize);
}

uint getCellId(ivec3 cellPos) {
    float cellSize = map_size / float(SH_size);
    return uint(cellPos.z * (SH_size*SH_size) +
                cellPos.y * SH_size +
                cellPos.x);
}

/*
    find cell_id of boid
    find size of each cell by atomicAdd b_cell_info[cell_id].size:

    fill b_cell_info starts:
        - go through all of them with one thread

    fill b_sorted using b_cell_info
*/

void main() {
    const uint id = gl_GlobalInvocationID.z * gl_NumWorkGroups.x * gl_NumWorkGroups.y +
                    gl_GlobalInvocationID.y * gl_NumWorkGroups.x +
                    gl_GlobalInvocationID.x;

    // if (id >= boid_count) return; // can't return before memory barrier
    const Boid boid = b_boid[id];

    ivec3 cellPos = getCellPos(boid.pos);
    uint cell_id = getCellId(cellPos);

    b_cell_id[id] = cell_id;

    atomicAdd(b_cell_info[cell_id].size, 1);

    // memoryBarrierBuffer();
    // memoryBarrierShared(); // Ensure change are visible in other invocations
    // memoryBarrierAtomicCounter();
    // barrier(); // Stall until every thread reached this point

    // const uint tmp_size = b_cell_info[cell_id].size;

    // use thread 0 to fill the .starts //TODO: probably could be done more parallel
    // Do this on CPU
    // if (id == 0) {
    //     const int SH_size3 = SH_size*SH_size*SH_size;
    //     uint offset = 0;
    //     for (int i = 1 ; i < SH_size3 ; ++i) {
    //         offset += b_cell_info[i - 1].size;
    //         b_cell_info[i].start = offset;
    //     }
    // }

    // fill b_sorted_id using b_cell_info
    // uint offset = atomicAdd(b_cell_info[cell_id].size, -1); // BUG HERE

    // b_sorted_id[b_cell_info[cell_id].start + offset] = id;
    // b_sorted_id[b_cell_info[cell_id].start + atomicAdd(b_cell_info[cell_id].size, -1)] = id;

    // b_cell_info[cell_id].size = tmp_size;
}
