#version 460 core

// #define LOCAL_SIZE_X 0
#define THREADS_X 64

#define CUBE 0
#define CUBE_T 0
#define SPHERE 0
#define SPHERE_T 0

#define PI 3.1415926535897932384626

layout(local_size_x=THREADS_X, local_size_y=1, local_size_z=1) in;

#include shaders/boids/boid_struct.glsl

layout(std430, binding=0) readonly buffer boids_in {
    Boid in_boids[];
};

layout(std430, binding=1) writeonly buffer boids_out {
    Boid out_boids[];
};

layout(std430, binding=2) readonly buffer buffer_cell_start {
    uint cell_start[];
};

layout(std430, binding=3) readonly buffer buffer_compact_cells {
    uint compact_cells[];
};

layout(std430, binding=4) readonly buffer buffer_cell_count {
    uint cell_count[]; // original value of cell_start
};

shared uint local_counter;

shared Boid neighbours[1024];

uniform int boid_count;
uniform float speed;
uniform float map_size;
uniform float view_distance;
uniform float view_angle;

uniform float separation_force;
uniform float alignment_force;
uniform float cohesion_force;

uniform float cell_spacing;

#include shaders/boids/cell_xyz.glsl
#include shaders/boids/hash.glsl


/*
load neighbours in shared memory
find/get the number of boid in current cell
distribute computation evenly between the 32 threads

TODO: need to keep the xyz coord in compacted cells because we can't convert back the index to xyz if they were negative

BUG: bug with negative cell coordinates nit being preserve after hash
*/

void main() {

    if (gl_LocalInvocationID.x == 0) {
        local_counter = 0;
    }

    memoryBarrierShared();

    const uint current_cell_index = compact_cells[gl_WorkGroupID.x];

    // this value is incorrect because cell_start is used previously to sort boids
    // const uint current_cell_boid_count = current_cell_index == 0 ? cell_start[current_cell_index] : cell_start[current_cell_index] - cell_start[current_cell_index - 1];
    const uint current_cell_boid_count = cell_count[current_cell_index];

    const uint boid_per_thread = uint(ceil(float(current_cell_boid_count) / float(THREADS_X)));

    // if (gl_LocalInvocationID.x < 27) {}

    // const ivec3 ourCell = index2Cell(current_cell_index); // problem here, not possible because of negative coords
    const ivec3 ourCell = cell_xyz(in_boids[cell_start[current_cell_index]].pos, cell_spacing);

    // use first thread of workgroup to load boids in shared memory
    if (gl_LocalInvocationID.x == 0) {
        for (int z = ourCell.z - 1; z <= ourCell.z + 1 && local_counter < 1023; ++z) {
        for (int y = ourCell.y - 1; y <= ourCell.y + 1 && local_counter < 1023; ++y) {
        for (int x = ourCell.x - 1; x <= ourCell.x + 1 && local_counter < 1023; ++x) {

            uint cell_index = hash(ivec3(x, y, z), boid_count);

            for (uint i = cell_start[cell_index] ; in_boids[i].cell_index == cell_index && i < boid_count ; ++i) {
                neighbours[local_counter] = in_boids[i];
                local_counter += 1;
                if (local_counter > 1023)
                    break;
            }
        }
        }
        }
    }
    memoryBarrierShared();
    memoryBarrier();

    for (int i = 0 ; i < boid_per_thread ; ++i) {
        uint index_in_workgroup = (gl_LocalInvocationID.x * boid_per_thread) + i;
        uint id = cell_start[current_cell_index] + index_in_workgroup;

        // if (index_in_workgroup > current_cell_boid_count) {
        //     break;
        // }

        // --
        vec3 ourDir = in_boids[id].dir.xyz;
        vec3 ourPos = in_boids[id].pos.xyz + (ourDir * speed);

        uint nb_flockmates = 0;
        vec3 averageDirection = vec3(0.0, 0.0, 0.0);
        vec3 averagePosition = vec3(0.0, 0.0, 0.0);
        vec3 totalForce = vec3(0.0, 0.0, 0.0);

        for (uint j = 0 ; j < local_counter ; ++j) {
            // if (gl_GlobalInvocationID.x == i) continue; // don't check if itself

            const vec3 otherPos = neighbours[j].pos.xyz;
            const vec3 otherDir = neighbours[j].dir.xyz;

            // if (distance(otherPos, ourPos) < 0.1) {
            if (all(ourPos == otherPos)) {
                continue;
            }


            const vec3 offset = ourPos - otherPos;
            const float sqrDist = dot(offset, offset);
            if (sqrDist < view_distance * view_distance) {

                // length definitly has an impact on performances
                const float r = dot((otherPos - ourPos)/length(otherPos - ourPos), ourDir/length(ourDir));
                if (length(acos(r)) <= view_angle) {
                    nb_flockmates += 1;
                    averageDirection += otherDir;
                    averagePosition += otherPos;

                    // separation
                    totalForce += offset / sqrDist;
                }
            }
        }

        // separation
        ourDir += totalForce * separation_force;

        if (nb_flockmates != 0) {
            // alignment
            averageDirection /= nb_flockmates;
            ourDir += averageDirection * alignment_force;

            // cohesion
            averagePosition /= nb_flockmates;
            ourDir += -(ourPos - averagePosition) * cohesion_force;
        }

        // border limit
        #if (CUBE == 1)
            const vec3 np = ourPos + (ourDir * speed);
            const float mp2 = map_size * 0.5;
            if (np.x < -mp2 || np.x > mp2 || np.y < -mp2 || np.y > mp2 || np.z < -mp2 || np.z > mp2) {
                const vec3 to_center = normalize(vec3(0, 0, 0) - ourPos);
                ourDir += to_center * 0.1;
            }
        #endif

        #if (CUBE_T == 1)
            const float map_size2 = map_size * 0.5;
            if (ourPos.x < -map_size2)
                ourPos.x = map_size2;
            else if (ourPos.x > map_size2)
                ourPos.x = -map_size2;

            if (ourPos.y < -map_size2)
                ourPos.y = map_size2;
            else if (ourPos.y > map_size2)
                ourPos.y = -map_size2;

            if (ourPos.z < -map_size2)
                ourPos.z = map_size2;
            else if (ourPos.z > map_size2)
                ourPos.z = -map_size2;
        #endif

        #if (SPHERE == 1)

            if (length(ourPos) > map_size) {
                const vec3 to_center = normalize(vec3(0, 0, 0) - ourPos);
                ourDir += to_center * 0.1;
            }
        #endif

        #if (SPHERE_T == 1)
            if (length(ourPos) > map_size) {
                ourPos = -normalize(ourPos) * map_size;
            }
        #endif

        out_boids[id].pos.xyz = ourPos;
        out_boids[id].dir.xyz = normalize(ourDir);
    }
}
