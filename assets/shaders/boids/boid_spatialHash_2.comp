#version 430

#define LOCAL_SIZE_X 0

layout(local_size_x=LOCAL_SIZE_X, local_size_y=1, local_size_z=1) in;

struct Boid {
    vec3 pos;
    uint a; // padding
    vec3 dir;
    uint cell_id;
};

layout(std430, binding=0) readonly buffer buffer_boids {
    Boid boids[];
};

layout(std430, binding=1) writeonly buffer buffer_cell_start {
    uint cell_start[];
};

uniform uint boid_count;

void main() {
    const uint index = gl_GlobalInvocationID.x;

    if (index >= boid_count)
        return;

    if (index == 0) {
        cell_start[boids[index].cell_id] = index;
        return;
    }

    if (boids[index - 1].cell_id != boids[index].cell_id) {
        cell_start[boids[index].cell_id] = index;
        return;
    }

    // cell_start[table[index].cell_id] = 0xFFFFFFFF;
}

//NOTE: Do not use memoryBarrier() with a number of dispatch that exceed some hardware limit (being around 49 000 for the RTX 2080 super)

/*
// stupidest sort algorithm
// - for every value looping the whole list and finding the index it should then place it
const uint my_value = table[boid_index].cell_id;
uint value = 0;
uint offset = 0;
uint sort_index = 0;

// memoryBarrier();

for (uint i = 0 ; i < boid_count ; ++i) {
    value = table[i].cell_id;
    if (i == boid_index) {
        continue;
    }
    if (my_value > value) {
        sort_index += 1;
    }
    else if ((i < boid_index) && (my_value == value)) {
        offset += 1;
    }
}

sort_index += offset;
*/
