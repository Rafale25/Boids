#version 430

#define LOCAL_SIZE_X 0

layout(local_size_x=512, local_size_y=1, local_size_z=1) in;

struct Boid {
    vec3 pos;
    float a; // padding
    vec3 dir;
    float b; // padding
};

struct Cell {
    uint cell_id;
    uint boid_id;
};

layout(std430, binding=0) readonly buffer buffer_0 {
    Boid boids[];
};

layout(std430, binding=1) readonly buffer buffer_1 {
    Cell table[];
};

layout(std430, binding=2) writeonly buffer buffer_2 {
    Cell sorted_table[];
};

layout(std430, binding=3) writeonly buffer buffer_3 {
    uint cell_start[];
};


// uniform float map_size;
uniform int boid_count;
uniform float cell_spacing;
uniform uint table_size;

ivec3 cell_xyz(vec3 pos) {
    return ivec3(floor(pos/cell_spacing));
}

uint hash(ivec3 cell_index) {
    int h = (cell_index.x * 92837111) ^ (cell_index.y * 689287499) ^ (cell_index.z * 283923481);
    return abs(h) % table_size;
    // const uint p1 = 73856093; // some large primes
    // const uint p2 = 19349663;
    // const uint p3 = 83492791;
    // uint n = p1 * cell_index.x ^ p2*cell_index.y ^ p3*cell_index.z;
    // n %= (table_size);
    // return n;
}


void main() {
    const uint boid_index = gl_GlobalInvocationID.z * gl_NumWorkGroups.y * gl_NumWorkGroups.x +
                            gl_GlobalInvocationID.y * gl_NumWorkGroups.x +
                            gl_GlobalInvocationID.x;

    const Boid boid = boids[boid_index];
    ivec3 cell_index = cell_xyz(boid.pos);
    uint hash_index = hash(cell_index);


    // stupidest sort algorithm
    // - for every value looping the whole list and finding the index it should then place it
    const uint my_value = table[boid_index].cell_id;
    uint value = 0;
    uint offset = 0;
    uint sort_index = 0;

    // memoryBarrier();

    for (uint i = 0 ; i < boid_count ; ++i) {
        value = table[i].cell_id;
        if (i == boid_index) {
            continue;
        }
        if (my_value > value) {
            sort_index += 1;
        }
        else if ((i < boid_index) && (my_value == value)) {
            offset += 1;
        }
    }

    sort_index += offset;

    sorted_table[sort_index].cell_id = hash_index;
    sorted_table[sort_index].boid_id = boid_index;


    // <- THE SORT SEEMS TO BE WORKING AS INTENDED (not completely sure)

    if (offset == 0) {
        cell_start[hash_index] = sort_index;
    }
}
