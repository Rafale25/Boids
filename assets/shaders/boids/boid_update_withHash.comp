#version 430

#define CUBE 0
#define CUBE_T 0
#define SPHERE 0
#define SPHERE_T 0

layout(local_size_x=512, local_size_y=1, local_size_z=1) in;

struct Boid {
    vec3 pos;
    float a; // useless as fuck
    vec3 dir;
    float b; // useless as fuck
};

layout(std430, binding=0) readonly buffer boids_in {
    Boid boids[];
} In_boids;

layout(std430, binding=1) writeonly buffer boids_out {
    Boid boids[];
} Out_boids;


/* hash */
struct CellInfo {
    uint start;
    uint size;
};

// sorted list of boid_id based on grid cell
layout(std430, binding=2) readonly buffer buffer_cell_info {
    CellInfo b_cell_info[]; // start, size
};

// sorted list of boid_id based on grid cell
layout(std430, binding=3) readonly buffer buffer_sorted_boids_id {
    uint b_sorted_id[]; // cell_id = boid_id
};

uniform int SH_size;


/* ---- */

uniform int boid_count;
uniform float speed;
uniform float map_size = 0;
uniform float view_distance;
uniform float view_angle;

uniform float separation_force;
uniform float alignment_force;
uniform float cohesion_force;

#define PI 3.1415926535897932384626

float map(float value, float min1, float max1, float min2, float max2) {
    return min2 + (value - min1) * (max2 - min2) / (max1 - min1);
}

float distSquared(vec3 A, vec3 B) {
    const vec3 C = A - B;
    return dot(C, C);
}

ivec3 getCellPos(vec3 p) {
    /* add map_size/2 to position because map is centered on origin
        divide by SH_size to convert xyz to cell indices on each axis */
    float cellSize = map_size / float(SH_size);
    return ivec3((p + (map_size/2.0)) / cellSize);
}

uint getCellId(ivec3 cellPos) {
    float cellSize = map_size / float(SH_size);
    return uint(cellPos.z * (SH_size*SH_size) +
            cellPos.y * SH_size +
            cellPos.x);
}

void main() {
    const uint id = gl_GlobalInvocationID.z * gl_NumWorkGroups.y * gl_NumWorkGroups.x +
                    gl_GlobalInvocationID.y * gl_NumWorkGroups.x +
                    gl_GlobalInvocationID.x;

    if (id >= boid_count) return;

    // const Boid boid = In_boids.boids[id];
    vec3 ourPos = In_boids.boids[id].pos + (In_boids.boids[id].dir * speed);
    vec3 ourDir = In_boids.boids[id].dir;

    int nb_flockmates = 0;
    vec3 averageDirection = vec3(0.0, 0.0, 0.0);
    vec3 averagePosition = vec3(0.0, 0.0, 0.0);
    vec3 totalForce = vec3(0.0, 0.0, 0.0); // test, delete this later

    ivec3 cellPos = getCellPos(In_boids.boids[id].pos);
    uint cell_id = getCellId(cellPos);

    // for (uint i = b_cell_info[cell_id].start; i < b_cell_info[cell_id].size ; ++i) {
    for (uint i = 0; i < b_cell_info[cell_id].size ; ++i) {
        const uint index = b_sorted_id[b_cell_info[cell_id].start + i];

        if (id == index) continue; // don't check if itself

        const vec3 theirPos = In_boids.boids[index].pos;
        const vec3 theirDir = In_boids.boids[index].dir;

    // for (int i = 0 ; i < boid_count ; ++i) {
    //     if (id == i) continue; // don't check if itself

        // const vec3 theirPos = In_boids.boids[i].pos;
        // const vec3 theirDir = In_boids.boids[i].dir;

        // tests
        const vec3 p = theirPos;
        const vec3 v = ourPos;
        const vec3 d = ourDir;
        const float r = dot((p - v)/length(p - v), d/length(d));

        const float sqrDist = distSquared(ourPos, theirPos);
        if (sqrDist < view_distance * view_distance) {
            if (length(acos(r)) <= view_angle) {
                nb_flockmates += 1;
                averageDirection += theirDir;
                averagePosition += theirPos;

                // separation
                totalForce += (ourPos - theirPos) / sqrDist;
            }
        }
    }

    // separation
    ourDir += totalForce * separation_force;

    if (nb_flockmates != 0) {
        // alignment
        averageDirection /= nb_flockmates;
        ourDir += averageDirection * alignment_force;

        // cohesion
        averagePosition /= nb_flockmates;
        ourDir += -(ourPos - averagePosition) * cohesion_force;
    }

    // border limit
    #if (CUBE == 1)
        const vec3 np = ourPos + (ourDir * speed);
        const float mp2 = map_size * 0.5;
        if (np.x < -mp2 || np.x > mp2 || np.y < -mp2 || np.y > mp2 || np.z < -mp2 || np.z > mp2) {
            const vec3 to_center = normalize(vec3(0, 0, 0) - ourPos);
            ourDir += to_center * 0.1;
        }
    #endif

    #if (CUBE_T == 1)
        const float map_size2 = map_size/2;
        if (ourPos.x <= -map_size2)
            ourPos.x = map_size2*0.999;
        else if (ourPos.x >= map_size2)
            ourPos.x = -map_size2*0.999;

        if (ourPos.y <= -map_size2)
            ourPos.y = map_size2*0.999;
        else if (ourPos.y >= map_size2)
            ourPos.y = -map_size2*0.999;

        if (ourPos.z <= -map_size2)
            ourPos.z = map_size2*0.999;
        else if (ourPos.z >= map_size2)
            ourPos.z = -map_size2*0.999;
    #endif

    #if (SPHERE == 1)

        if (length(ourPos) > map_size) {
            const vec3 to_center = normalize(vec3(0, 0, 0) - ourPos);
            ourDir += to_center * 0.1;
        }
    #endif

    #if (SPHERE_T == 1)
        if (length(ourPos) > map_size) {
            ourPos = -normalize(ourPos) * map_size;
        }
    #endif

    Out_boids.boids[id].pos = ourPos;
    Out_boids.boids[id].dir = normalize(ourDir);
}
