#version 430

#define LOCAL_SIZE_X 0

layout(local_size_x=LOCAL_SIZE_X, local_size_y=1, local_size_z=1) in;

// struct Boid {
//     vec3 pos;
//     float a; // padding
//     vec3 dir;
//     float b; // padding
// };
struct Boid {
    vec4 pos;
    vec4 dir;
};

struct Cell {
    uint cell_id;
    uint boid_id;
};

layout(std430, binding=0) readonly buffer buffer_0 {
    Boid boids[];
};

layout(std430, binding=1) writeonly buffer buffer_1 {
    Cell table[];
};

uniform float cell_spacing;
uniform uint total_grid_cell_count;
// uniform uint

ivec3 cell_xyz(vec3 pos)
{
    return ivec3(floor(pos/cell_spacing));
}

uint hash(ivec3 cell_index) {
    // int h = (cell_index.x * 92837111) ^ (cell_index.y * 689287499) ^ (cell_index.z * 283923481);
    // return abs(h) % total_grid_cell_count;

    // const int MAX_SIZE = 64;
    // const uint maskx = MAX_SIZE-1;
    // const uint masky = MAX_SIZE-1;
    // const uint maskz = MAX_SIZE-1;
    // const uint width = MAX_SIZE;
    // const uint width_height = MAX_SIZE*MAX_SIZE;
    // return (cell_index.x&maskx)+(cell_index.y&masky)*width+(cell_index.z&maskz)*width_height;

    const uint MAX_SIZE = 80;
    uint i = (cell_index.z * MAX_SIZE*MAX_SIZE) +
            (cell_index.y * MAX_SIZE) +
            cell_index.x;

    return i % total_grid_cell_count;
}


void main() {
    const uint boid_index = gl_GlobalInvocationID.x;

    const Boid boid = boids[boid_index];
    ivec3 cell_index = cell_xyz(boid.pos.xyz);
    uint hash_index = hash(cell_index);

    table[boid_index].cell_id = hash_index;
    table[boid_index].boid_id = boid_index;
}
