#version 430

layout(local_size_x=512, local_size_y=1, local_size_z=1) in;

struct Boid {
    vec3 pos;
    float a; // useless as fuck
    vec3 dir;
    float b; // useless as fuck
};

struct CellInfo {
    uint start;
    uint size;
};

// layout(std430, binding=0) readonly buffer buffer_boids {
//     Boid b_boid[];
// };

// cell id of each boid
layout(std430, binding=1) readonly buffer buffer_cell_id {
    uint b_cell_id[]; // boid_id = cell_id
};

// sorted list of boid_id based on grid cell
layout(std430, binding=2) buffer buffer_cell_info {
    CellInfo b_cell_info[]; // start, size
};

// sorted list of boid_id based on grid cell
layout(std430, binding=3) writeonly buffer buffer_sorted_boids_id {
    uint b_sorted_id[]; // cell_id... = boid_id
};
/* ---- */


uniform int boid_count;
// uniform float map_size;

/*
example: SH_size = 8 -> 8*8*8 = 512
how many cell in an axis
SH_size is not the size of the cell
*/
// uniform int SH_size;

void main() {
    const uint id = gl_GlobalInvocationID.z * gl_NumWorkGroups.x * gl_NumWorkGroups.y +
                    gl_GlobalInvocationID.y * gl_NumWorkGroups.x +
                    gl_GlobalInvocationID.x;

    // if (id >= boid_count) return; // can't return before memory barrier

    const uint cell_id = b_cell_id[id];
    const uint tmp_size = b_cell_info[cell_id].size;

    memoryBarrier();
    memoryBarrierBuffer();
    memoryBarrierShared(); // Ensure change are visible in other invocations
    memoryBarrierAtomicCounter();
    barrier(); // Stall until every thread reached this point

    // fill b_sorted_id using b_cell_info
    const uint offset = atomicAdd(b_cell_info[cell_id].size, -1); // BUG HERE

    memoryBarrier();
    memoryBarrierBuffer();
    memoryBarrierShared(); // Ensure change are visible in other invocations
    memoryBarrierAtomicCounter();
    barrier(); // Stall until every thread reached this point

    b_sorted_id[b_cell_info[cell_id].start + offset] = id;

    memoryBarrier();
    memoryBarrierBuffer();
    memoryBarrierShared(); // Ensure change are visible in other invocations
    memoryBarrierAtomicCounter();
    barrier(); // Stall until every thread reached this point

    b_cell_info[cell_id].size = tmp_size;
}
